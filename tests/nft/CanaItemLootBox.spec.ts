/* libraries used */
import { contract, web3 } from 'hardhat'
import hre, { ethers } from "hardhat";
import { ContractFactory, EventFilter } from "ethers";
import { BigNumber } from 'ethers'
/* libraries used */

import * as setup from "../../lib/setupCreatureAccessories"
import * as vals from "../../lib/valuesCommon"
import * as testVals from "../../lib/testValuesCommon";
import * as utils from '../utils'

const truffleAssert = require('truffle-assertions')


/* Contracts in this test */
import {   
  CanaItem,
  CanaItemFactory,
  CanaItemLootBox
} from 'src/gen/typechain'

import { 
  expect,
  assert,
  RevertError,
} from '../utils'
/* Useful aliases */

const toBN = web3.utils.toBN;


/* Utility Functions */

// Not a function, the fields of the TransferSingle event.

const TRANSFER_SINGLE_FIELDS = [
  { type: 'address', name: '_operator', indexed: true },
  { type: 'address', name: '_from', indexed: true },
  { type: 'address', name: '_to', indexed: true },
  { type: 'uint256', name: '_id' },
  { type: 'uint256', name: '_amount' }
];

const {
  wallet: ownerWallet,
  provider: ownerProvider,
  signer: ownerSigner
} = utils.createTestWallet(web3, 0)

const {
  wallet: userWallet,
  provider: userProvider,
  signer: userSigner
} = utils.createTestWallet(web3, 2)

// Not a function, the keccak of the TransferSingle event.

const TRANSFER_SINGLE_SIG = web3.eth.abi.encodeEventSignature({
  name: 'TransferSingle',
  type: 'event',
  inputs: TRANSFER_SINGLE_FIELDS
});

// Total the number of tokens in the transaction's emitted TransferSingle events
// Keep a total for each token id number (1:..2:..)
// and a total for *all* tokens as total:.

const totalEventTokens = (receipt, recipient) => {
  // total is our running total for all tokens
  const totals = {total: toBN(0)};
  // Parse each log from the event
  for (let i = 0; i < receipt.logs.length; i++) {
    const raw = receipt.logs[i];
    // Filter events so we process only the TransferSingle events
    // Note that topic[0] is the event signature hash
    if (raw.topics[0] === TRANSFER_SINGLE_SIG) {
      // Fields of TransferSingle
      let parsed = web3.eth.abi.decodeLog(
        TRANSFER_SINGLE_FIELDS,
        raw.data,
        // Exclude event signature hash from topics that we process here.
        raw.topics.slice(1)
      );
      // Make sure the address that we are watching got the tokens.
      // Burnt tokens go to address zero, for example
      if (parsed._to == recipient) {
        // Keep a running total for each token id.
        const id = parsed._id;
        if (! totals[id]) {
          totals[id] = toBN(0);
        }
        const amount = toBN(parsed._amount);
        totals[id] = totals[id].add(amount);
        // Keep a running total for all token ids.
        totals.total = totals.total.add(amount);
      }
    }
  }
  return totals;
};

// Compare the token amounts map generated by totalEventTokens to a spec object.
// The spec should match the guarantees[] array for the option.

const compareTokenTotals = (totals, spec, option) => {
  Object.keys(spec).forEach(key => {
    assert.isOk(
      // Because it's an Object.keys() value, key is a string.
      // We want that for the spec, as it is the correct key.
      // But to add one we want a number, so we parse it then add one.
      // Why do we want to add one?
      totals[parseInt(key)] || toBN(0).gte(spec[key]),
      `Mismatch for option ${option} guarantees[${key}]`
    );
  });
};


/* Tests */

describe("CanaItemLootBox", () => {
    
  let canaItemLootBox: CanaItemLootBox;
  let userCanaItemLootBox: CanaItemLootBox;
  let canaItemFactory: CanaItemFactory;
  let userCanaItemFactory: CanaItemFactory;
  let canaItem: CanaItem;
  let userCanaItem:CanaItem;

  let ownerAddress: string;
  let userAddress: string;

  before(async () => {
    const _canaItemFactory: ContractFactory = await ethers.getContractFactory(
      "CanaItem"
    )
    canaItem = (await _canaItemFactory.deploy()) as CanaItem;
    await canaItem.deployed();
    userCanaItem = await canaItem.connect(userSigner);
    
    const Library = await ethers.getContractFactory("CanaBoxLib");
    const library = await Library.deploy();
    await library.deployed();

    const canaItemLootBoxFactory: ContractFactory = await ethers.getContractFactory("CanaItemLootBox", {
      libraries: {
        CanaBoxLib: library.address,
      },
    });
    canaItemLootBox = await canaItemLootBoxFactory.deploy() as CanaItemLootBox;
    canaItemLootBox.deployed();

    const canaItemFactoryFactory: ContractFactory = await ethers.getContractFactory("CanaItemFactory");
    canaItemFactory = await canaItemFactoryFactory.deploy(
      canaItem.address,
      canaItemLootBox.address
      ) as CanaItemFactory;
      canaItemFactory.deployed();
    userCanaItemFactory = await canaItemFactory.connect(userSigner)

    ownerAddress = await ownerWallet.getAddress();
    userAddress = await userWallet.getAddress();

    await setup.setupAccessory(canaItem, ownerAddress);
    await canaItem.setApprovalForAll(
      canaItemFactory.address,
      true,
      { from: ownerAddress }
    );
    await canaItem.transferOwnership(canaItemFactory.address);
    await setup.setupAccessoryLootBox(canaItemLootBox, canaItemFactory);
    userCanaItemLootBox = await canaItemLootBox.connect(userSigner);
  });

  // Calls _mint()

  describe('#mint()', () => {
    it('should work for owner()', async () => {
      const option = vals.LOOTBOX_OPTION_BASIC;
      const amount = 1;
      const tx = await canaItemLootBox.mint(
        userAddress,
        option,
        amount,
        [],
        { from: ownerAddress }
      );
      const receipt = await tx.wait(1);      
      const ev = receipt.events!.pop()!;
      expect(ev.event).to.be.eql('TransferSingle');
      const args = ev.args! as any;
      expect(args.from).to.be.eql(testVals.ADDRESS_ZERO);
      expect(args.to).to.be.eql(userAddress);
      expect(args.id).to.be.eql(BigNumber.from(option));
      expect(args.value).to.be.eql(BigNumber.from(amount));      
    });    

    it('should not be callable by non-owner() and non-proxy', async () => {
      const amount = (1);
      await expect(
        userCanaItemLootBox.mint(
          userAddress,
          vals.LOOTBOX_OPTION_PREMIUM,
          amount,
          [],
          { from: userAddress }
        )
      ).to.be.rejectedWith(RevertError("Lootbox: owner or proxy only"));
    });

    it('should not work for invalid option', async () => {
      const amount = (1);
      await expect( 
        canaItemLootBox.mint(
          userAddress,
          vals.NO_SUCH_LOOTBOX_OPTION,
          amount,
          [],
          { from: ownerAddress }
        )
      ).to.be.rejectedWith(RevertError("Lootbox: Invalid Option"));
    });
  });

  describe('#unpack()', () => {
    it('should mint guaranteed class amounts for each option', async () => {
      for (let i = 0; i < vals.NUM_LOOTBOX_OPTIONS; i++) {
        const option = vals.LOOTBOX_OPTIONS[i];
        const amount = (1);
        
        await canaItemLootBox.mint(
          userAddress,
          option,
          amount,
          [],
          { from: ownerAddress } //Todo: check, this is proxy
        );
        const tx = await userCanaItemLootBox.unpack(
          // Token IDs are option IDs
          option,
          userAddress,
          amount,
          { from: userAddress }
        );

        const receipt = await tx.wait(1);                     
        const ev = receipt.events!.pop()!;
        expect(ev.event).to.be.eql('LootBoxOpened');
        const args = ev.args! as any;
        expect(args.boxesPurchased).to.be.eql(BigNumber.from(amount));
        expect(args.optionId).to.be.eql(BigNumber.from(option));
        expect(args.buyer).to.be.eql(userAddress);
        expect(args.itemsMinted).to.be.eql(BigNumber.from(vals.LOOTBOX_OPTION_AMOUNTS[option]));         

        const totals = totalEventTokens(receipt, userAddress);
        assert.ok(totals.total.eq(toBN(vals.LOOTBOX_OPTION_AMOUNTS[option])));
        compareTokenTotals(totals, vals.LOOTBOX_OPTION_GUARANTEES[option], option);
      }
    });
  });
});
